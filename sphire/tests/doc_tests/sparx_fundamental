-) ccf(e, f, center=True)
-) scf(e, center=True)
-) cyclic_shift(img, dx=0, dy=0, dz=0)
-) mirror(img, axis='x')
-) fft(e, npad=1)
-) fftip(e)
-) fpol(image, nnx, nny=1, nnz=1, RetReal=True, normalize=True)
-) fdecimate(image, nnx, nny=1, nnz=1, RetReal=True, normalize=True)
-) fshift(e, delx=0, dely=0, delz=0)
-) subsample(image, subsample_rate=1.0)
-) resample(img, sub_rate=0.5)
-) prepi(image, RetReal = True)
-) prepi3D(image)
-) ramp(inputimage)
-) rot_avg_table(e)
-) rops_table(img, lng = False)
-) gridrot_shift2D(image, ang=0.0, sx=0.0, sy=0.0, scale=1.0)
-) rot_shift2D(img, angle=0.0, sx=0.0, sy=0.0, mirror=0, scale=1.0, interpolation_method=None, mode="background")
-) rot_shift3D(image, phi=0, theta=0, psi=0, sx=0, sy=0, sz=0, scale=1.0, mode="background")
-) rtshg(image, angle=0.0, sx=0.0, sy=0.0, scale=1.0)
-) rtshgkb(image, angle, sx, sy, kb, scale=1.0)
-) smallprime(arbit_num, numprime=3)
-) tilemic(img, win_size=512, overlp_x=50, overlp_y=50, edge_x=0, edge_y=0)
-) window2d(img, isize_x, isize_y, opt="c", ix=0, iy=0)
-) rotate_params(params, transf)
-) rotmatrix(phi, theta, psi)
-) mulmat(m1, m2)
-) recmat(mat)

################################################################################################################################################################################################################################################
    ccf(e, f, center=True)
    e --> img
    f --> img
    center --> If true, put the center of the correlation in the middle	else in (0,0) ( see fourierproduct in libEM/sparx/fundamental.cpp)
Returns the circulant cross-correlation function of images e and f. Input images may be real or complex.  Output image is real.    1-D, 2-D, or 3-D images supported.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    scf(e, center=True)
    e --> img
    center --> If true, put the center of the correlation in the middle	else in (0,0) ( see fourierproduct in libEM/sparx/fundamental.cpp)
Returns the circulant self-correlation function of the input image. Real.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    cyclic_shift(img, dx=0, dy=0, dz=0)
        Name
            cyclic_shift - cyclically shift an image by an integer number of pixels
        Input
            image: input image
            ix: (optional) integer number of pixels by which the image has to be shifted in the x direction, can be negative
            iy: (optional) integer number of pixels by which the image has to be shifted in the y direction, can be negative
            iz: (optional) integer number of pixels by which the image has to be shifted in the z direction, can be negative
        Output
            output image
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    mirror(img, axis='x')
    img --> img
    axis --> axis where the mirror will be performed
Returns the mirrored img
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    fft(e, npad=1)
    img --> img
    npad --> axis where the mirror will be performed
Returns the Out-of-place  fft or ift of the given img
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    fftip(e)
    e --> img
Returns the In-of-place  fft or ift of the given img
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    fpol(image, nnx, nny=1, nnz=1, RetReal=True, normalize=True)
        Name
            fpol -Interpolate image up by padding its Fourier transform with zeroes
        Input
            image: image to be interpolated.
            nnx: new nx dimension
            nny: new ny dimension (default = 0, meaning equal to the original ny)
            nnz: new nz dimension (default = 0, meaning equal to the original nz)
            RetReal:     Logical flag, if True, the returned image is real, if False, it is Fourier
            normalize:   Logical flag, if True, the returned image is normalized such that the power (sum of amplitudes squared) is preserved
        Output
            the output interpolated up image
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    fdecimate(image, nnx, nny=1, nnz=1, RetReal=True, normalize=True)
        Decimate image by truncating its Fourier transform
        Input
            image: image to be interpolated.
            nnx: new nx dimension
            nny: new ny dimension (default = 0, meaning equal to the original ny)
            nnz: new nz dimension (default = 0, meaning equal to the original nz)
            RetReal:     Logical flag, if True, the returned image is real, if False, it is Fourier
            normalize:   Logical flag, if True, the returned image is normalized such that the power (sum of amplitudes squared) is preserved
        Output
            the output decimated image
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    fshift(e, delx=0, dely=0, delz=0)
        Name
            fshift - shift an image using phase multiplication in Fourier space
        Input
            image: input image
            sx: shift in pixels in the x direction, can be negative
            sy: shift in pixels in the y direction, can be negative
            sz: shift in pixels in the z direction, can be negative
        Output
            output image
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    subsample(image, subsample_rate=1.0)
    image --> img
    subsample_rate --> rate of subsample
subsample image by an arbitrary factor (<1) - the image size will decrease, the physical pixel size will increase.
Input image is convoluted in real space with a sinc-Blackman window and sampled
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    resample(img, sub_rate=0.5)
		resample image based on the value of sub_rate.
		the input image can be either 2D image or 3D volume.
		sub_rate < 1.0, subsampling the image.
		sub_rate > 1.0, upsampling the image using new gridding interpolation.
		fit_to_fft will change the ouput image size to an fft_friendly size
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    prepi(image, RetReal = True)
		Name
			prepi - prepare 2-D image for rotation/shift
		Input
			image: input image that is going to be rotated and shifted using rtshgkb
		Output
			imageft: real space image prepared for gridding rotation and shift by convolution
			kb: interpolants (tabulated Kaiser-Bessel function)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    prepi3D(image)
		Name
			prepi3D - prepare 3-D image for rotation/shift
		Input
			image: input image that is going to be rotated and shifted using rot_shif3D_grid
		Output
			imageft: image prepared for gridding rotation and shift
			kb: interpolants (tabulated Kaiser-Bessel function)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    ramp(inputimage)
		Name
			ramp - remove linear trend from a 2D image
		Input
			image: 2D input image
		Output
			2D output image from which a 2D plane was subtracted
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    rot_avg_table(e)
	   Rotational average.
	   Returns a table containing a rotational average of image e.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    rops_table(img, lng = False)
    	Calculate 1D rotationally averaged
		power spectrum and save it in list
		when lng is True it applies log10 to the output elements
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    gridrot_shift2D(image, ang=0.0, sx=0.0, sy=0.0, scale=1.0)
    Rotate and shift an image using gridding in Fourier space
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    rot_shift2D(img, angle=0.0, sx=0.0, sy=0.0, mirror=0, scale=1.0, interpolation_method=None, mode="background")
        rotate/shift image using (interpolation_method):
        1. linear    interpolation
        2. quadratic interpolation
        3. gridding
        4. ftgridding
        5. fourier
        mode specifies what will be put in corners, should they stick out:
        background - leave original values
        cyclic - use pixels from the image using wrap-around transformation

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    rot_shift3D(image, phi=0, theta=0, psi=0, sx=0, sy=0, sz=0, scale=1.0, mode="background")
        Name
            rot_shift3D - rotate, shift, and scale a 3D image
        Input
            image:3D image to be rotated
            phi, theta, psi: Euler angles ( in SPIDER convention ) describing rotation
            sx, sy, sz: x, y and z shifts, respectively
            scale: rescaling factor. scale > 1 will magnify the input volume.
            mode: backgroud
        Output
            The rotated, shifted, and scaled output 3D volume
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    rtshg(image, angle=0.0, sx=0.0, sy=0.0, scale=1.0)

        Name
            rtshg - rotate and shift a 2D image using the gridding method
        Input
            image: a 2D input image
            alpha: rotation angle
            sx: x shift (default = 0.0)
            sy: y shift (default = 0.0)
            scale: magnification change (default = 1.0)
        Output
            the output rotated and shifted image
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    rtshgkb(image, angle, sx, sy, kb, scale=1.0):
        Name
            rtshgkb - rotate and shift a 2D image using the gridding method.
        Input
            sx: x shift
            sy: y shift
            kb: interpolants
        Output
            the output rotated and shifted image
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    smallprime(arbit_num, numprime=3)
    arbit_num --> ????
    numprime --> ???
????
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    tilemic(img, win_size=512, overlp_x=50, overlp_y=50, edge_x=0, edge_y=0)
    img --> img
    win_size --> size of the period
    overlp_x --> overlap size in x
    overlp_y --> overlap size in y
    edge_x --> ???
    edge_y --> ??
Calculate set of periodograms for tiles.  Returns a list.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    window2d(img, isize_x, isize_y, opt="c", ix=0, iy=0)
    img --> img
    isize_x --> size x of the new img
    isize_y  --> size y of the new img
    opt --> ways of windowing out a portion of an image:
    	"c" Get the central part: "c" ( default setting )
		"l" Get clip starts from the top left corner
		"a" Get clip with arbitrary point (ix, iy) as the image center point ( nx//2,ny//2 corresponds to image center )
    ix --> origin x of the image
    iy --> origin y of the image
Returns a part of the given image
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    rotate_params(params, transf)
    params --> parameters to rotate. List of list of 3 elements
    transf --> list rotation param (phi, theta, psi)
Rotates each list of params with the list 'transf'. Returns a list of list of 3 elemts
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    rotmatrix(phi, theta, psi)
    Given 3 angles, returns the matrix's rotation
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    mulmat(m1, m2)
    returns multiplication between 2 [3x3] matrix
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

################################################################################################################################################################################################################################################
    recmat(mat)
    Given a 3x3 matrix returns the rotation's parameter [phi,theta,psi]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



################################################################################################################################################################################################################################################
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



################################################################################################################################################################################################################################################
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



################################################################################################################################################################################################################################################
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



################################################################################################################################################################################################################################################
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



################################################################################################################################################################################################################################################
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



################################################################################################################################################################################################################################################
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



################################################################################################################################################################################################################################################
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



################################################################################################################################################################################################################################################
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



################################################################################################################################################################################################################################################
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



################################################################################################################################################################################################################################################
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------











